<!DOCTYPE html>
<html lang="IT">

  <head>
      <meta http-equiv="content-type" content="text/html;
       charset=UTF-8">
       <link rel="stylesheet" type="text/css" href="../grafica.css">
      <title>Appunti Programmazione</title>

      <link rel="icon" href="./../icon.png" type="image/x-icon" />
      <link rel="shortcut icon" href="./../icon.png" type="image/x-icon" />

  </head>

  <body>

    <section style="background-color: #113448">
      <nav  class="navgeneral" style="width: 10%;">
        <h2><a href="./../index.html">Homepage</a></h2>
      </nav>
      <header style="width: 90%;">
        <h2>Appunti di Programmazione (JAVA) - Teoria</h2>
      </header>
    </section>

    <section>

      <nav>
        <ul class="navul">
          <li><a class="a-null" href="#iteratori">Iteratori</a></li>
          <li><a class="a-null" href="#ereditarieta">Ereditarietà</a></li>

        </ul>
      </nav>

    <article>
      <div class="generaldiv">
        <div class="div-20">
          <!--Introduction-->
          <h2>Introduzione</h2>
          <p>Al fine di poter realizzare progetti grandi, al quale vi lavorano più persone. È importante suddivide il proprio progetto in piccole parti inidpendeti che poi verranno collegate. <br>
            Un'altro fattore molto importante è la descrizione del codice al fine di permettere la immediata comprensione ad'altra persona che vi ci interagisce. <br><br>
            La soddivisione del codive in piccoli moduli deve garantire:
          </p>
          <ul>
            <li>Ogni modolo deve avere lo stesso livello di dettaglio.</li>
            <li>Ogni modulo beve poter essere risolto indipendentemente.</li>
            <li>La combinazione della soluzione dei moduli deve produrre la soluzione del problema originale.</li>
          </ul>
          <h4>Astrazione</h4>
          <p>L'astrazione ci permette di idividuare il problema non tenedo traccia di tutte le problematiche, questo ci permette di semplificare il problema in un primo momento in modo da rende la suddivisione in moduli molto più semplice.</p>
          <!--Introduction-->
        </div>
        <hr>
        <div class="div-20">
          <!--JAVA-chapter2-->
          <h2>Principi di Java</h2>
          <p>Java è un linguaggio orientato ad oggetti. I suoi programmi sono costruiti da:</p>
          <ul>
            <li>Classi: utilizzate per definire:
            <ul>
              <li>Collezione di procedure (detti Metodi)</li>
              <li>Nuovi tipi di Dato</li>
            </ul>
          </li>
          <li>Interfacce</li>
          </ul>
          <h4>Package</h4>
          <p>I package servono per raggruppare più classi e/o più interfacce. Essi servono come meccanismo di incampulamento che percìmette la comunicazione interna tra le diverse class ie interfacce, ma non permette la comunicazione verso l'esterno (a meno di apposite entità di visibilità). <br>
          Un'altro loro scopo è quello di poter nominare un pacchetto. (Questo permette di avere metodi uguali in pacchetti diversi) </p>
          <h4>Mutabilità degli oggetti</h4>
          <p>Gli oggetti possono essere:</p>
          <ul>
            <li>Mutabili: possono cambiare nel tempo.</li>
            <li>Immutabili: una volta inizializzati non possono essere più mutati. (Es. String)</li>
          </ul>
          <p>Chiamando un metodo di un oggetto mutazionale esso può modificare lo sato di tale oggetto nella sua istanza.</p>
          <h2>Pagina 46</h2>

          <!--JAVA-chapter2-->
          <hr>
        </div>
        <div class="div-20">
          <p>
            <a name="iteratori"></a>
            <h2>ITERAZIONE</h2>
            <h4>Motivazione/Descrizione:</h4>
            <p>Si vuole ottenere tutte quelle funzioni aggiuntive ad un contenitore. <br>
            Soluzioni: </p>
            <ul>
              <li>creare le funzioni interne (solo se appartente proprio al contenitore).</li>
              <li>creare le funzioni in modo esterno (passando una copia della rappresentazione interna all'esterno) [Onerosa perchè fa una copia, perdita di tempo e memoria].
              Meglio usare un ITERAZIONE ESTERNA.</li>
            </ul> <br>
            <p> <b>Esempio:</b> Classi Contenitori, classi che sono in grado di raccogliere oggetti di grandezze simili. Es: InstSet, Poly, Queue.
            Voglio calcolare la somma di tutti gli elementi dell'insieme. Che sono oprzioni aggiuntive rispetto a quel contenitore (ad es. un insime di interi non è pensato per restituire la somma dei suoi interi).</p> <br>
            <h4>Come vanno specificate:</h4>
            <p>Si crea un GENERATORE che dal contenitore estrae uno alla volta un oggetto tramite una copia.</p> <br>
            <h4>Interfaccia:</h4>
            <p>Sono un elenco di Metodi. Serve per definire che una determinata classe soddisfa una interfaccia. Di queste interfacce esiste ITERATOR<E>.</p>
            <div class="codediv"><b>
              <pre>
Interface Iterator&ltE> { <a class="acomment">//Intertore presente dentro al contenitore per la Liskov</a>
    boolean hasNext();
    E next();
}

Class SetElements Implements Iterator&ltInteger> { <a class="acomment">//Generatore per la Liskov</a>
}


Interator it = o.iterator() <a class="acomment">//iterator è un metodo interno implementato da un'interfaccia</a>
while(it.hasNext()) {
E x it.next()
      ...x....
}

<a class="acomment">FOR EACH:</a>
    for( E x : o) { <a class="acomment">//dove o è l'iteratore</a>

    }
              </pre>
            </b></div>
            <p>Interfaccia che mi dice se qualcosa è iterabile:</p>
            <div class="codediv"><b>
              <pre>
interface Iterabel<E> {
    iterator&lte> iterator();
}
              </pre>
            </b></div>
            <p>Una classe iterabile vuol dire che c'è esattamente un metodo di nome iteretor il quale restituisce un generatore di elementi. (Iterator&lte>) <br>

            - GENERATORE: è un oggetto di una Classe che implementa un Iterator. <br>

            Affinche la classe che genera il genratore deve essere dentro la classe contenitore.</p>
            <h4>Nested Class:</h4>

            <div class="divflex">
              <div class="div-5">
                <b>Static Nested Class:</b>
              </div>
              <div class="div-10">
                <p>Può avere attributi o classi. [New.Outer.Nested] <br>
                Può visualizzare tutte le variabili e i metodi della classe superiore anche se private. <br>
                Gli oggetti della classe interna non hanno niente a che vedere con i valori eserni. <br>
                Non possono accedere alle istanze delle classi. <br>
                Si può solo tramite un costruttore interno a cui viene passata l'istanza dell'oggetto esterno.</p>
              </div>
            </div> <br>
            <div class="divflex">
              <div class="div-5">
                <b>Inner:</b>
              </div>
              <div class="divnoflex">
                <div class="divflex">
                  <div class="div-5">
                    <b>Locali:</b>
                  </div>
                  <div class="div-10">
                    Posso vedere gli oggetti della classe esterna. Per la sua creazione si può usare x = new X(); [classe esterna] quindi fare y = x.new.Y(); [classe interna].
                    La nozione di istanza interna può essere associata solo e soltanto ad una istanza esterna. Non può essere preso esternamente.
                  </div>
                </div> <br>
                <div class="divflex">
                  <div class="div-5">
                    <b>Anonime:</b>
                  </div>
                  <div class="div-10">
                    Classe scritta dentro un metodo.
                    <div class="codediv">
                      <pre>
Class x {
      metodo f {
            new I() {  }; //Espressione dove I è l'intefaccia.
      }
}
                      </pre>
                    </div>

                  </div>
                </div>
              </div>
            </div>
            <p>
              <b> Specificazione:</b> nella documentazione dell'iteratore (secondo la Liskov). [Metodi che implementano un generatore]. <br> <br>
              <b>Invariante di Rapprsentazione:</b> documentazione codice del generatore (Liskov). [Stato del generatore]. <br><br>
              <b>Implementazione:</b>
            </p>
            <ul>
              <li> <b>Contenitore:</b> con il suo stato privato </li>
              <li> <b>Generatore:</b> con il suo stato pubblico (Deve poter comunicare con il contenitore). </li>
            </ul>




            </p>
            <hr>
            <a name="ereditarieta"></a>
            <h2>EREDITARIETÀ</h2>
            <p>Possibilità di utilizzare i metodi di una gerarchia andando verso l'alto.</p>
            <h3>Perchè sviluppare una gerarchia?</h3>
            <p>Per poter rappresentare oggetti che sono simili, ma hanno alcuni comportamenti diversi.</p>
            <ul>
              <li>                                          -  Vogliamo specializzare il comportamento di certi oggetti sottotipi di un'altro. (Stessi metodi, ma implementati diversamente affinche faccino cose diverse).</li>
              <li>                                          -  Vogliamo estendere il comportamento. Padre: insieme di interi; Figlio: insieme di interi ordinato.(Aggiunta di metodi).</li>
              <li>                                          -  Si vogliono avere diverse implementazione (Il metodo fa la stessa cosa, ma tenendo conte diverse implementazioni). Non ha bisogno di specificazione in quanto si comporta allo stesso modo.</li>
              <li>                                          -  Ricalcare "Ontologica" (Eccezioni - Gerarchia esistende da rispecchiare sui diversi tipi [astratta]).</li>
            </ul>
            <br>
            <h4><a href="#PrincipioSostituzioneLiskov">Principio di Sostituizone della Liskov:<a></h4>
            <p>             Le istanze della classe padre devono poter essere sempre aggiunte ad una classe figlia.</p>
            <br>
            <h3>Come si può fare?</h3>
            <p>Gli assegnamenti e i parametri posso passarli sempre un sottotipo. (Es: Number x = new Double(3); //Dove Double è figlio di Number). <br>
            Espressioni: </p>
            <ul>
              <li>- Tipo apparente (Può essere deciso dal compilatore). [Contenitore grande]</li>
              <li>- Tipi concreti: in esecuzione determinano il vero tipo della funzione (Deve essere eseguito solo attraverso RunTime). [Contenitore piccolo]</li>
            </ul>
            <br>
            <h3>Dispatching:</h3>
            <ul>
              <li>
                <p>x.f(e0, e1,....)
                Non è possibile determinare il tipo concreto in fase di compilazione, in quanto il metodo potrebbe essere presente in divere classi. D'altro canto è molto importante riuscire a capire quale metodo invocare in Esecuzione. <br>
               Si risolve con: </p>
               <ul>
                 <li>
                   <p>A tempo di compilazione:</p>
                   <ul>
                     <li>1) se Esiste f (con il tipo apparente di x e isuoi super tipi).</li>
                     <li>2) segnatura (andando a prendere la segnatura più specifica).</li>
                   </ul>
                 </li>
                 <li>
                   <p>A tempo di Esecuzione:</p>
                   <ul>
                     <li>3) Dispatching - scegliere qual è il metodo appropriato utilizzando il tipo concreto.</li>
                   </ul>
                 </li>
               </ul>
              </li>
            </ul>
            <br>
            <h3>Come si specificano?</h3>
            <ul>
              <li>  - In alcuni sottotipi nno c'è bisgono di specificare perchè fanno le stesse cose del super tipo.</li>
              <li>- Qual'ora sia un'estensione di una classe, si rifà al supertipo e specifica i metodi aggiuntivi.</li>
              <li>- Qual'ora la specificazione è diversa, bisogna speicficare i comportamenti aggiuntivi rifacendosi al super tipo, aggiungendo richieste, non modificandone le caratteristiche in quanto ereditarie.</li>
            </ul>
            <br>
            <hr class="hr70">
            <h3>Come si possono fare?</h3>
            <ul>
              <li> <b>interfaccia:</b>
                          Un insieme di metodi con specificazione. I metodi sono privi di codice. Questo supertipo specifica il comportamento di tutti i figli senza specificarne come. Esso è molto usato quando si vuole avere diverse implementazioni della stessa cosa. Non può essere implementata. Implementano.</li> <br>
              <li><b>Classi astratte:</b>
                              Una classe che implemneta alcuni metodi, mentre altri metodi determinano solo una specifica. Sono nel mezzo delle interfacce e delle classi concrete. Non possono essere implemntate, in quanto mancano dei metodi implementati. Estendono.</li> <br>
              <li><b>Classi concrete:</b>
                              Raccolta di metodi e di stato che realizza un insieme di comportamenti. Si può avere un'implementazione proria. Estendono.</li> <br>
            </ul>
            <h3>Quali sono le differenze tra queste 3?</h3>
            <ul>
              <li><b>Interfacce:</b>
                          Definire in modo specifico quali sono i comportamenti che devono avere le sue sottoclassi. In tal modo mi assicuro che tutta la gerarchia che parte dalle Interfacce implemneta tali metodi in modo proprio in base alla propria implementazione. <br>
                          Ultimamente vengono aggiunti delle implementazioni. Vi sono presenti anche dei metodi di default. Definisce un comportamento in termini degli altri metodi senza entrare nello stato. (Un metodo che può essere definito esclusivamente dagli altri metodi, indipendentemente della loro implementazione).</li>
              <li><b>Classi astratte:</b>
                              Implementati per la codivisione del codice, vecchio java. Esse hanno sempre delle classi inferiori che implemnetano le parti mancanti della classe astratta. Può definire anche alcuni comportamenti. Abstract metode. Posso riusare il codice, ma perdo l'icapsulamento in quanto do libero accesso alle sottoclassi del mio stato.</li>
              <li>
                <b>Classi concrete:</b>
                <ul>
                  <li> <b>Metodi:</b>
                    <ul>
                      <li>- Statici: Legati alla classe, di conseguenza non fanno parte della ereditarietà.</li>
                      <li>- Istanza nuovi: non presenti nel super tipo.</li>
                      <li>  - Istanza ereditati: presi dal super tipo. Non vengono implementati.</li>
                      <li>- Istanze sovrascritti: presenti nel super tipo. Ma vengo implemnetati con la sovrascritti.</li>
                      <li>  - Final: non vogliammo che venga sovrascritto da un sottotipo.</li>
                    </ul>
                  </li>
                  <li> <b>Attributi:</b>
                    <ul>
                      <li>- Statici: non vengono ereditati.</li>
                      <li>- Ereditati: vengono ereditati.</li>
                      <li>- Nuovi: non presneti nella super classe.</li>
                    </ul>
                  </li>
                  <li> <b>Invariante di Rappresentazione:</b> dovrà rifarsi sugli attributi nuovi e sulla super classe. </li>
                  <li> <b>Funzione di astrazione: </b>"Principio di sostituzione" - l'oggetto non deve essere diverso. Di conseguenza la funzione di astrazione deve rimanere sostanzialmente invariata. </li>
                </ul>
              </li>
            </ul>
            <br>
            <p>Una classe può estendere solo una classe. Ma può implementare più interfacce. Ereditarietà multipla. <br>
            Se una classe estende una classe e implementa una interfaccia che entrambe presentano un metodo uguale  sia nella classe che nella interfaccia come metodo default. In genere vince l'implementazione concreta della classe.</p>
            <br>
            <h3>Operatori di visibilità:</h3>
            <ul>
              <li> <b>- Public:</b> visibile a tutti.</li>
              <li> <b>- Private: </b>visibile solo alla sua classe. </li>
              <li> <b>- niente: </b>(Package private) visibile solo e soltanto all'interno dei pacchetti. </li>
              <li> <b>- Protected: </b> Visibile a se stesso e alla sua sottoclasse. Da qualsiasi package.</li>
            </ul>
            <p>Un' ottimo modo per non dover passare la rappresentazione ad una sottoclasse è usare un iteratore.</p>


        </div>
        <div class="div-20">
          <hr>
          <br>
          <a name="PrincipioSostituzioneLiskov"></a>
          <h3>Principio di sostituzione di Liskov</h3>
          <p>Se esitono certe relazioni di sottotipo. Il programma deve funzione per tutte le occorenze di T sostituisco con S. Dove S è un sottotipo di T. Di conseguenza posso sostituire tutte le sottoclassi alle superclassi e il programma deve continuare a funzionare.</p>
          <ul>
            <li>Regola delle segnature: per ogni metodo che c'è in T ci deve essere lo stesso metodo in S con le segnature compatibili (stesso nome, stessi paramentri passati, solleva meno eccezioni, possono tornare diversi valori di ritorno purchè siano più spacifici).</li>
            <li>Regola dei metodi: Specificazione. <br>
              <ul>
                <li>- Indebolire le precondiozini: Le precondizioni del tipo implicano le pecondizioni del sottotipo. Se sono vere le precondizioni del sottotipo allora lo sono del sottotipo.</li>
                <li>- Rafforzare le postcondizioni: Se valgono le postcondizioni di S e le precondizioni di T devono valere le postcondizionidi T. Questo perchè ho indebolito le precondizioni. Quindi le cose che vanno bene per la sottoclasse devono essere valide per la superclasse.</li>
                <li>- Particolare attenzione al metodo Equals: S è una sottoclasse di T. Dove S ha le variabili a e b. T ha la varaibile a.
                In S verifico che l'oggetoo o sia di tipo S. Chiamo il super tipo di T per confrontare le variabili a di S e di o.</li></li>
              </ul>
              <li>Regola delle proprietà: Tutte le proprietà che sono valide su T, devono essere valide anche su S.</li>
          </ul>

          <!--Chiusura-->
        </div>
        <div class="div-20">
          <hr>
          <h3>Polimorfismo</h3>

          1)Abbiamo già visto il polimorfismo nella forma di (sub)typing per sottotipi (Interfacce e successive implementazioni). Tipo concreto/apparente

          2)Polimorfisfo ad hoc:
                - overload (comportamento che cambia in funzione degli argomenti passati. Esso dipende dai paramentri passati)
                - overriding (doto un sottotipo di comportamenti diversi. Esso dipende dalla forma concreta del tipo)

          3)Polimorfismo Parametrico: meccanismo Generic Type. Astrazione dai parametri e dai tipi.

          <h3>Generici (Tipo)</h3>

          Consentono la Type safeness (contenitori sicuri rispetto al tipo).

          Specificazione: Indicazione dei comportamenti + indicazioni su quali tipi di base sono.

          class T &ltX,Y,...> {

            void f(X p) {...};
            Y g() {...};

          }

          new T &ltString, Que>;

          Si astrae da che tipo sia l'oggetto, considerando che se fosse un oggetto generico.

          <h3>Collezioni</h3>

          List  Array/Linked
          Set Hash/Alberi
          Mappe Hash/Alberi

          Algoritmi: sorting. Ci sono 2 metodi:
          - Tramite classe COMPARATOR (una classe che prende 2 generi e restituisce quale dei 2 è il più grande). Interfaccia COMPARABLE che possiede un COMPARATOR.

          Tipo Generico: class C&ltT> {....T....};
          Tipo Parametrico: C&ltString> e = new C&lt>();

          Metodi Generici
          Dichiarazione: .......&ltT> f(........T....) { ... T...... }
          Invocazione: x.&ltString>f(....) //Inferenza di tipo, si può non scrivere il tipo

          Cosa succede nei generici: durante la copilazione viene attivato il Type Erasure che sostituisce tutti i tipi generi con un tipo oggetto, vengon aggiunti tutti i cast e dei metodi ponte per garantirne il funzionamento. Il tipo finale viene chiamato RAWTYPE (tipo nudo).

          BOUND:
          WILDCARD:

          <h4>Testing e Debugging</h4>

          Validation - Convalida: Si comprende cosa vuole l'utente. Stiamo costruendo la cosa giusta?
          Verification - Verifica: Si verifica che il prodotto soddisfa le esigenza. Stiamo costrento la cosa in modo corretto?
                    In modo Formale (Prove di Correttezza)
                    Testing
                    Defensive Programming

          Testing

          Contrasto tra riultato Atteso (Expected) e il risualtato attuale (Actual)
          - I test devono essere "piccoli" e "rappresentativi"

          Si usa 2 metodi diversi ed opposti:

          Black Box Testing: Sulla base delle specifiche ottengo un possibile effetto.
                            - non hanno Implementazione.
                            - robusta.
                            - Possono essere fatti da esterni.

          Glass Box Testing: Guardo l'implementazione.
                            - Selezione/Iterazione/Ricorsione
                            - Coverage

          Procedure - Iteratori - Tipi di Dati - Costruttori

          Test UNITARI: sugli singoli moduli - Tools
          Test Integrazione: tramite specificazione mettendo inisieme i test UNITARI
          Test Regressione: Test su eventuali modifiche.

          Tools:
                - Costruire dei test case (a mano)
                - Esecuzione
                              Setup: Preparo l'ambiente
                              Controllo SUT: Subject under test   //  DOC: Dependent of component: Nono viene usata l'implementazione originale, ma una simile STUB
                              Esecuzione dei test
                              Teardown: cancello e risistemo dopo l'interfaccia
                - Reporting


          <!--Chiusura-->
        </div>
        <!--Chiusura finale intero articolo-->
      </div>
    <!--Chiura finale della div riguardante l'articolo -->
    </article>
    </section>
  </body>
</html>
