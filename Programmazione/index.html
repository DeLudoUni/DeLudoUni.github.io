<!DOCTYPE html>
<html lang="IT">

  <head>
      <meta http-equiv="content-type" content="text/html;
       charset=UTF-8">
       <link rel="stylesheet" type="text/css" href="../grafica.css">
      <title>Appunti Programmazione</title>

      <link rel="icon" href="./../icon.png" type="image/x-icon" />
      <link rel="shortcut icon" href="./../icon.png" type="image/x-icon" />

  </head>

  <body>

    <section style="background-color: #113448">
      <nav  class="navgeneral" style="width: 10%;">
        <h2><a href="./../index.html">Homepage</a></h2>
      </nav>
      <header style="width: 90%;">
        <h2>Appunti di Programmazione (JAVA) - Teoria</h2>
      </header>
    </section>

    <section>

      <nav>
        <ul class="navul">
          <li><a class="a-null" href="#iteratori">Iteratori</a></li>
          <li><a class="a-null" href="#ereditarieta">Ereditarietà</a></li>

        </ul>
      </nav>

    <article>
      <div class="generaldiv">
        <div class="div-20">
          <!--Introduction-->
          <h2>Introduzione</h2>
          <p>Al fine di poter realizzare progetti grandi, al quale vi lavorano più persone. È importante suddivide il proprio progetto in piccole parti inidpendeti che poi verranno collegate. <br>
            Un'altro fattore molto importante è la descrizione del codice al fine di permettere la immediata comprensione ad'altra persona che vi ci interagisce. <br><br>
            La soddivisione del codive in piccoli moduli deve garantire:
          </p>
          <ul>
            <li>Ogni modolo deve avere lo stesso livello di dettaglio.</li>
            <li>Ogni modulo beve poter essere risolto indipendentemente.</li>
            <li>La combinazione della soluzione dei moduli deve produrre la soluzione del problema originale.</li>
          </ul>
          <h4>Astrazione</h4>
          <p>L'astrazione ci permette di idividuare il problema non tenedo traccia di tutte le problematiche, questo ci permette di semplificare il problema in un primo momento in modo da rende la suddivisione in moduli molto più semplice.</p>
          <!--Introduction-->
        </div>
        <hr>
        <div class="div-20">
          <!--JAVA-chapter2-->
          <h2>Principi di Java</h2>
          <p>Java è un linguaggio orientato ad oggetti. I suoi programmi sono costruiti da:</p>
          <ul>
            <li>Classi: utilizzate per definire:
            <ul>
              <li>Collezione di procedure (detti Metodi)</li>
              <li>Nuovi tipi di Dato</li>
            </ul>
          </li>
          <li>Interfacce</li>
          </ul>
          <h4>Package</h4>
          <p>I package servono per raggruppare più classi e/o più interfacce. Essi servono come meccanismo di incampulamento che percìmette la comunicazione interna tra le diverse class ie interfacce, ma non permette la comunicazione verso l'esterno (a meno di apposite entità di visibilità). <br>
          Un'altro loro scopo è quello di poter nominare un pacchetto. (Questo permette di avere metodi uguali in pacchetti diversi) </p>
          <h4>Mutabilità degli oggetti</h4>
          <p>Gli oggetti possono essere:</p>
          <ul>
            <li>Mutabili: possono cambiare nel tempo.</li>
            <li>Immutabili: una volta inizializzati non possono essere più mutati. (Es. String)</li>
          </ul>
          <p>Chiamando un metodo di un oggetto mutazionale esso può modificare lo sato di tale oggetto nella sua istanza.</p>
          <h2>Pagina 46</h2>

          <!--JAVA-chapter2-->
          <hr>
        </div>
        <div class="div-20">
          <p>
            <a name="iteratori"></a>
            <h2>ITERAZIONE</h2>
            <h4>Motivazione/Descrizione:</h4>
            <p>Si vuole ottenere tutte quelle funzioni aggiuntive ad un contenitore. <br>
            Soluzioni: </p>
            <ul>
              <li>creare le funzioni interne (solo se appartente proprio al contenitore).</li>
              <li>creare le funzioni in modo esterno (passando una copia della rappresentazione interna all'esterno) [Onerosa perchè fa una copia, perdita di tempo e memoria].
              Meglio usare un ITERAZIONE ESTERNA.</li>
            </ul> <br>
            <p> <b>Esempio:</b> Classi Contenitori, classi che sono in grado di raccogliere oggetti di grandezze simili. Es: InstSet, Poly, Queue.
            Voglio calcolare la somma di tutti gli elementi dell'insieme. Che sono oprzioni aggiuntive rispetto a quel contenitore (ad es. un insime di interi non è pensato per restituire la somma dei suoi interi).</p> <br>
            <h4>Come vanno specificate:</h4>
            <p>Si crea un GENERATORE che dal contenitore estrae uno alla volta un oggetto tramite una copia.</p> <br>
            <h4>Interfaccia:</h4>
            <p>Sono un elenco di Metodi. Serve per definire che una determinata classe soddisfa una interfaccia. Di queste interfacce esiste ITERATOR<E>.</p>
            <div class="codediv"><b>
              <pre>
Interface Iterator&ltE> { <a class="acomment">//Intertore presente dentro al contenitore per la Liskov</a>
    boolean hasNext();
    E next();
}

Class SetElements Implements Iterator&ltInteger> { <a class="acomment">//Generatore per la Liskov</a>
}


Interator it = o.iterator() <a class="acomment">//iterator è un metodo interno implementato da un'interfaccia</a>
while(it.hasNext()) {
E x it.next()
      ...x....
}

<a class="acomment">FOR EACH:</a>
    for( E x : o) { <a class="acomment">//dove o è l'iteratore</a>

    }
              </pre>
            </b></div>
            <p>Interfaccia che mi dice se qualcosa è iterabile:</p>
            <div class="codediv"><b>
              <pre>
interface Iterabel<E> {
    iterator&lte> iterator();
}
              </pre>
            </b></div>
            <p>Una classe iterabile vuol dire che c'è esattamente un metodo di nome iteretor il quale restituisce un generatore di elementi. (Iterator&lte>) <br>

            - GENERATORE: è un oggetto di una Classe che implementa un Iterator. <br>

            Affinche la classe che genera il genratore deve essere dentro la classe contenitore.</p>
            <h4>Nested Class:</h4>

            <div class="divflex">
              <div class="div-5">
                <b>Static Nested Class:</b>
              </div>
              <div class="div-10">
                <p>Può avere attributi o classi. [New.Outer.Nested] <br>
                Può visualizzare tutte le variabili e i metodi della classe superiore anche se private. <br>
                Gli oggetti della classe interna non hanno niente a che vedere con i valori eserni. <br>
                Non possono accedere alle istanze delle classi. <br>
                Si può solo tramite un costruttore interno a cui viene passata l'istanza dell'oggetto esterno.</p>
              </div>
            </div> <br>
            <div class="divflex">
              <div class="div-5">
                <b>Inner:</b>
              </div>
              <div class="divnoflex">
                <div class="divflex">
                  <div class="div-5">
                    <b>Locali:</b>
                  </div>
                  <div class="div-10">
                    Posso vedere gli oggetti della classe esterna. Per la sua creazione si può usare x = new X(); [classe esterna] quindi fare y = x.new.Y(); [classe interna].
                    La nozione di istanza interna può essere associata solo e soltanto ad una istanza esterna. Non può essere preso esternamente.
                  </div>
                </div> <br>
                <div class="divflex">
                  <div class="div-5">
                    <b>Anonime:</b>
                  </div>
                  <div class="div-10">
                    Classe scritta dentro un metodo.
                    <div class="codediv">
                      <pre>
Class x {
      metodo f {
            new I() {  }; //Espressione dove I è l'intefaccia.
      }
}
                      </pre>
                    </div>

                  </div>
                </div>
              </div>
            </div>
            <p>
              <b> Specificazione:</b> nella documentazione dell'iteratore (secondo la Liskov). [Metodi che implementano un generatore]. <br> <br>
              <b>Invariante di Rapprsentazione:</b> documentazione codice del generatore (Liskov). [Stato del generatore]. <br><br>
              <b>Implementazione:</b>
            </p>
            <ul>
              <li> <b>Contenitore:</b> con il suo stato privato </li>
              <li> <b>Generatore:</b> con il suo stato pubblico (Deve poter comunicare con il contenitore). </li>
            </ul>




            </p>
            <hr>
            <a name="ereditarieta"></a>
            <h2>EREDITARIETÀ</h2>
            <p>Possibilità di utilizzare i metodi di una gerarchia andando verso l'alto.</p>
            <h3>Perchè sviluppare una gerarchia?</h3>
            <p>Per poter rappresentare oggetti che sono simili, ma hanno alcuni comportamenti diversi.</p>
            <ul>
              <li>                                          -  Vogliamo specializzare il comportamento di certi oggetti sottotipi di un'altro. (Stessi metodi, ma implementati diversamente affinche faccino cose diverse).</li>
              <li>                                          -  Vogliamo estendere il comportamento. Padre: insieme di interi; Figlio: insieme di interi ordinato.(Aggiunta di metodi).</li>
              <li>                                          -  Si vogliono avere diverse implementazione (Il metodo fa la stessa cosa, ma tenendo conte diverse implementazioni). Non ha bisogno di specificazione in quanto si comporta allo stesso modo.</li>
              <li>                                          -  Ricalcare "Ontologica" (Eccezioni - Gerarchia esistende da rispecchiare sui diversi tipi [astratta]).</li>
            </ul>
            <br>
            <h4>Principio di Sostituizone della Liskov:</h4>
            <p>             Le istanze della classe padre devono poter essere sempre aggiunte ad una classe figlia.</p>
            <br>
            <h3>Come si può fare?</h3>
            <p>Gli assegnamenti e i parametri posso passarli sempre un sottotipo. (Es: Number x = new Double(3); //Dove Double è figlio di Number). <br>
            Espressioni: </p>
            <ul>
              <li>- Tipo apparente (Può essere deciso dal compilatore). [Contenitore grande]</li>
              <li>- Tipi concreti: in esecuzione determinano il vero tipo della funzione (Deve essere eseguito solo attraverso RunTime). [Contenitore piccolo]</li>
            </ul>
            <br>
            <h3>Dispatching:</h3>
            <ul>
              <li>
                <p>x.f(e0, e1,....)
                Non è possibile determinare il tipo concreto in fase di compilazione, in quanto il metodo potrebbe essere presente in divere classi. D'altro canto è molto importante riuscire a capire quale metodo invocare in Esecuzione. <br>
               Si risolve con: </p>
               <ul>
                 <li>
                   <p>A tempo di compilazione:</p>
                   <ul>
                     <li>1) se Esiste f (con il tipo apparente di x e isuoi super tipi).</li>
                     <li>2) segnatura (andando a prendere la segnatura più specifica).</li>
                   </ul>
                 </li>
                 <li>
                   <p>A tempo di Esecuzione:</p>
                   <ul>
                     <li>3) Dispatching - scegliere qual è il metodo appropriato utilizzando il tipo concreto.</li>
                   </ul>
                 </li>
               </ul>
              </li>
            </ul>
            <br>
            <h3>Come si specificano?</h3>
            <ul>
              <li>  - In alcuni sottotipi nno c'è bisgono di specificare perchè fanno le stesse cose del super tipo.</li>
              <li>- Qual'ora sia un'estensione di una classe, si rifà al supertipo e specifica i metodi aggiuntivi.</li>
              <li>- Qual'ora la specificazione è diversa, bisogna speicficare i comportamenti aggiuntivi rifacendosi al super tipo, aggiungendo richieste, non modificandone le caratteristiche in quanto ereditarie.</li>
            </ul>
            <br>
            <hr class="hr70">
            <h3>Come si possono fare?</h3>
            <ul>
              <li> <b>interfaccia:</b>
                          Un insieme di metodi con specificazione. I metodi sono privi di codice. Questo supertipo specifica il comportamento di tutti i figli senza specificarne come. Esso è molto usato quando si vuole avere diverse implementazioni della stessa cosa. Non può essere implementata. Implementano.</li> <br>
              <li><b>Classi astratte:</b>
                              Una classe che implemneta alcuni metodi, mentre altri metodi determinano solo una specifica. Sono nel mezzo delle interfacce e delle classi concrete. Non possono essere implemntate, in quanto mancano dei metodi implementati. Estendono.</li> <br>
              <li><b>Classi concrete:</b>
                              Raccolta di metodi e di stato che realizza un insieme di comportamenti. Si può avere un'implementazione proria. Estendono.</li> <br>
            </ul>
            <h3>Perchè usare queste 3 differenze?</h3>
            <ul>
              <li><b>Interfacce:</b>
                          Definire in modo specifico quali sono i comportamenti che devono avere le sue sottoclassi. In tal modo mi assicuro che tutta la gerarchia che parte dalle Interfacce implemneta tali metodi in modo proprio in base alla propria implementazione.</li>
              <li><b>Classi astratte:</b>
                              Implementati per la codivisione del codice, vecchio java. Esse hanno sempre delle classi inferiori che implemnetano le parti mancanti della classe astratta.</li>
              <li>
                <b>Classi concrete:</b>
                <ul>
                  <li> <b>Metodi:</b>
                    <ul>
                      <li>- Statici: Legati alla classe, di conseguenza non fanno parte della ereditarietà.</li>
                      <li>- Istanza nuovi: non presenti nel super tipo.</li>
                      <li>  - Istanza ereditati: presi dal super tipo. Non vengono implementati.</li>
                      <li>- Istanze sovrascritti: presenti nel super tipo. Ma vengo implemnetati con la sovrascritti.</li>
                      <li>  - Final: non vogliammo che venga sovrascritto da un sottotipo.</li>
                    </ul>
                  </li>
                  <li> <b>Attributi:</b>
                    <ul>
                      <li>- Statici: non vengono ereditati.</li>
                      <li>- Ereditati: vengono ereditati.</li>
                      <li>- Nuovi: non presneti nella super classe.</li>
                    </ul>
                  </li>
                  <li> <b>Invariante di Rappresentazione:</b> dovrà rifarsi sugli attributi nuovi e sulla super classe. </li>
                  <li> <b>Funzione di astrazione: </b>"Principio di sostituzione" - l'oggetto non deve essere diverso. Di conseguenza la funzione di astrazione deve rimanere sostanzialmente invariata. </li>
                </ul>
              </li>
            </ul>
            <br>
            <h3>Operatori di visibilità:</h3>
            <ul>
              <li> <b>- Public:</b> visibile a tutti.</li>
              <li> <b>- Private: </b>visibile solo alla sua classe. </li>
              <li> <b>- niente: </b>(Package private) visibile solo e soltanto all'interno dei pacchetti. </li>
              <li> <b>- Protected: </b> Visibile a se stesso e alla sua sottoclasse. Da qualsiasi package.</li>
            </ul>
            <p>Un' ottimo modo per non dover passare la rappresentazione ad una sottoclasse è usare un iteratore.</p>


        </div>
        <!--Chiusura finale intero articolo-->
      </div>


    <!--Chiura finale della div riguardante l'articolo -->

    </article>
    </section>
  </body>
</html>
